require 'ffi'

require 'aix/errlog/constants'

module AIX
  module Errlog
    PARSE_REGEX = /(?:^Detail Data$\n(.*?))?(?:^Symptom Data$\n(.*))?\z/m.freeze

    ##
    # An errlog entry class.  Used to parse the raw errlog_entry_t struct into a
    # more useful Ruby object.
    # 
    # You shouldn't need to invoke this class directly; it is generated by the
    # Errlog#forward_each and Errlog#reverse_each.
    #
    # Unfortunately, the retreived detail and symptom fields aren't horribly
    # useful, and IBM has presented no API for parsing these correctly, so the
    # only canonical path to getting the correct detail and symptom data is
    # through a call to the errpt command.
    class Entry
      attr_reader :magic, :sequence, :label, :timestamp, :crcid, :errdiag, :machineid, :nodeid, :class, :type, :resource, :rclass, :rtype, :vpd_ibm, :vpd_user, :in, :connwhere, :flags, :raw_detail, :raw_symptom, :dup_count, :dup_time1, :dup_time2, :wparid

      def initialize(raw)
        @magic = raw[:el_magic]
        @sequence = raw[:el_sequence]
        @label = raw[:el_label].to_s.freeze
        @timestamp = Time.at(raw[:el_timestamp]).freeze
        @crcid = raw[:el_crcid]
        @errdiag = raw[:el_errdiag]
        @machineid = raw[:el_machineid].to_s.freeze
        @nodeid = raw[:el_nodeid].to_s.freeze
        @class = raw[:el_class].to_s.freeze
        @type = raw[:el_type].to_s.freeze
        @resource = raw[:el_resource].to_s.freeze
        @rclass = raw[:el_rclass].to_s.freeze
        @rtype = raw[:el_rtype].to_s.freeze
        @vpd_ibm = raw[:el_vpd_ibm].to_s.freeze
        @vpd_user = raw[:el_vpd_user].to_s.freeze
        @in = raw[:el_in].to_s
        @connwhere = raw[:el_connwhere].to_s.freeze
        @flags = raw[:el_flags]
        length = raw[:el_detail_length]
        @raw_detail = raw[:el_detail_data].to_ptr.get_bytes(0, length).freeze
        length = raw[:el_symptom_length]
        @raw_symptom = raw[:el_symptom_data].to_ptr.get_bytes(0, length).freeze
        @dup_count = raw[:el_errdup][:ed_dupcount]
        @dup_time1 = Time.at(raw[:el_errdup][:ed_time1]).freeze
        @dup_time2 = Time.at(raw[:el_errdup][:ed_time2]).freeze
        @wparid = raw[:el_wparid].to_s.freeze
      end

      def errpt
        @errpt ||= %x(errpt -al#{@sequence}).freeze
      end

      def parse_errpt
        unless @parsed
          @detail, @symptom = errpt.match(PARSE_REGEX).captures
          @detail ||= ''.freeze
          @symptom ||= ''.freeze
          @detail.freeze
          @symptom.freeze
          @parsed = true
        end
      end
      def detail
        parse_errpt unless @parsed
        @detail 
      end
      def symptom
        parse_errpt unless @parsed
        @symptom 
      end
    end
  end
end
